/**
 * This ruleset defines the security model for a heritage site application.
 *
 * Core Philosophy:
 * The security model is split into three distinct zones:
 * 1. Public Content: Heritage sites and their associated artifacts are publicly readable by anyone, including unauthenticated users, to encourage exploration.
 * 2. Administrative Content: Writes (creation, updates, deletion) to public content are strictly limited to users designated as administrators.
 * 3. Private User Data: Each user has a private data space for their profile and preferences, which is accessible only by them.
 *
 * Data Structure:
 * - /heritage_sites/{siteId}: Publicly readable information about historical sites.
 * - /heritage_sites/{siteId}/artifacts/{artifactId}: Publicly readable artifacts belonging to a site.
 * - /users/{userId}: Private user profile data, keyed by the user's authentication UID.
 * - /users/{userId}/preferences/{prefId}: Private user preferences, nested under their profile.
 * - /roles_admin/{userId}: A separate collection that grants admin privileges. A user is an admin if a document with their UID exists here.
 *
 * Key Security Decisions:
 * - Admin Role Management: Admin roles are managed in the `/roles_admin` collection. Only existing admins can create or delete other admins, preventing privilege escalation. The first admin must be created via the Firebase Console.
 * - No User Enumeration: Listing the entire `/users` collection is explicitly forbidden to protect user privacy.
 * - Relational Integrity: On creation, an artifact's internal `siteId` must match its parent `heritageSiteId` in the path. These linkage fields are immutable.
 *
 * Denormalization for Authorization:
 * - Admin roles are checked using a simple `exists()` call on the `/roles_admin` collection. This is a fast, efficient, and highly secure way to manage global roles without needing custom claims or complex lookups.
 *
 * Structural Segregation:
 * - Public data (`heritage_sites`) is stored in a separate top-level collection from private data (`users`). This physical separation creates a strong security boundary, simplifying rules and preventing accidental data leakage in list queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Returns true if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the requesting user's UID matches the provided userId.
     * Ensures a user can only access their own documents.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the requesting user is an administrator.
     * Admin status is granted by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Returns true if the document being operated on already exists.
     * Used to protect against updating or deleting non-existent documents.
     */
    function documentExists() {
      return resource != null;
    }

    // --------------------------------------------------------------------
    // Public Content Rules
    // --------------------------------------------------------------------

    /**
     * @description Publicly readable information about heritage sites.
     *              Only administrators are allowed to create, update, or delete sites.
     * @path        /heritage_sites/{heritageSiteId}
     * @allow       Any user, signed-in or not, can (get) or (list) heritage sites.
     * @allow       An admin user can (create) a new heritage site.
     * @deny        A regular signed-in user cannot (delete) a heritage site.
     * @principle   Public read with role-based writes.
     */
    match /heritage_sites/{heritageSiteId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && documentExists();
    }

    /**
     * @description Artifacts associated with a specific heritage site.
     *              Publicly readable, but writable only by administrators.
     * @path        /heritage_sites/{heritageSiteId}/artifacts/{artifactId}
     * @allow       Any user, signed-in or not, can (get) or (list) artifacts for a site.
     * @allow       An admin user can (create) a new artifact with a `siteId` matching the parent `heritageSiteId`.
     * @deny        An admin user cannot (create) an artifact where the `siteId` in the data does not match the path.
     * @principle   Public read with role-based writes and relational integrity.
     */
    match /heritage_sites/{heritageSiteId}/artifacts/{artifactId} {
      allow get, list: if true;
      allow create: if isAdmin() && request.resource.data.siteId == heritageSiteId;
      allow update: if isAdmin() && documentExists() && request.resource.data.siteId == resource.data.siteId;
      allow delete: if isAdmin() && documentExists();
    }

    // --------------------------------------------------------------------
    // User Data Rules
    // --------------------------------------------------------------------

    /**
     * @description A user's private profile document.
     *              Strictly accessible only by the owner of the document.
     * @path        /users/{userId}
     * @allow       A signed-in user (auth.uid: 'user123') can (create) their own profile at `/users/user123`.
     * @deny        A signed-in user (auth.uid: 'user456') cannot (get) the profile at `/users/user123`.
     * @deny        No user can (list) the `/users` collection, preventing user enumeration.
     * @principle   Enforces strict data ownership and privacy.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && documentExists() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && documentExists();
    }

    /**
     * @description A user's private application preferences.
     *              Only the owner of the parent user document can access these.
     * @path        /users/{userId}/preferences/{prefId}
     * @allow       A signed-in user (auth.uid: 'user123') can (get), (list), and (update) their own preferences.
     * @deny        A signed-in user (auth.uid: 'user456') cannot (create) preferences for 'user123'.
     * @principle   Ownership inherited from parent path.
     */
    match /users/{userId}/preferences/{prefId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == prefId;
      allow update: if isOwner(userId) && documentExists() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && documentExists();
    }

    // --------------------------------------------------------------------
    // Admin Role Rules
    // --------------------------------------------------------------------

    /**
     * @description Manages administrator roles. The existence of a document grants admin privileges.
     *              Only existing administrators can view or modify the list of admins.
     * @path        /roles_admin/{userId}
     * @allow       An existing admin can (create) a document to grant another user admin rights.
     * @deny        A non-admin user cannot (create) a document for themselves to become an admin.
     * @deny        A non-admin user cannot (list) the collection to see who the admins are.
     * @principle   Role-based access control for administrative functions (self-managed).
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && documentExists();
    }
  }
}